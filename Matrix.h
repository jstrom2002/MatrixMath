#ifndef MATRIX_H
#define MATRIX_H
#pragma once
#include "stdafx.h"

class Matrix {//matrix with real, exact values.  note: call row 1, column 1 with get(0,0)
public: 
	std::vector<double> element;
	int rows;
	int columns;
	int matrixPrecision;
	int largestElement;
	int modulus;

		Matrix();
		~Matrix();
		Matrix(int n);
		Matrix(int row, int col);
		Matrix(int row, int col, std::vector<double> element2);
		Matrix(int row, int col, std::vector<unsigned char> element2);
		Matrix(std::vector<std::vector<double>> elm);

		//function prototypes
		Matrix add(Matrix A, Matrix B);
		Matrix add(Matrix A, double B);
		Matrix addColumn(std::vector<double> vec);
		Matrix addColumn(int j, std::vector<double> vec);
		Matrix addRow(std::vector<double> vec);
		Matrix addRow(int i, std::vector<double> vec);
		void addToRow(int rw, double n);
		void addToRow(int rw, std::vector<double> n);
		void addToColumn(int cl, double n);
		void addToColumn(int cl, std::vector<double> n);
		double adjustedRsquared();
		Matrix autoCorrelation(Matrix A);
		double biggestValue();
		Matrix BooleanProduct(Matrix A, Matrix B);
		bool canSwapOutZeroDiagonals();
		Matrix characteristicMatrix();
		Polynomial characteristicPolynomial();
		double ChiSquareDegreesFreedom();
		double ChiSquareTestStatistic();
		Matrix Cholesky();
		std::vector<double> column(int c);
		double columnAbsMax(int r);
		double columnMax(int r);
		double columnCovariance(int c1, int c2);
		double columnDeviation(int c);
		double columnMean(int c);
		double columnAbsMin(int r);
		double columnMin(int r);
		int columnNonzeroValues(int rw);
		double columnNorm(int c);
		double columnSumSquares(int c);
		double columnVariance(int c);
		Matrix concatenate(Matrix A, Matrix B);
		Matrix convolve(Matrix A, Matrix B);
		Matrix crossCorrelation(Matrix A, Matrix B);
		double det();
		double detExact();
		std::vector<double> diagonal();
		Matrix directSum(Matrix A, Matrix B);
		void display();
		Matrix dominantEigenvector();
		double dominantEigenvalue();
		std::vector<double> eigenvaluesByGaussianElimination();
		std::vector<double> eigenvaluesRealExact();
		std::vector<double> eigenvaluesNumerical();
		std::vector<ComplexNumber> eigenvaluesRealAndComplexExact();
		Matrix eigenvalueMatrix();
		Matrix eigenvalueMatrix(Matrix A, int loops);
		Matrix eigenvectors();
		Matrix expandToUpperLeft(int r, int c);
		Matrix expandToLowerRight(int r, int c);
		Matrix extendRows(int r);
		Matrix extendColumns(int c);
		Matrix exponent(Matrix A, int b);
		std::vector<double> findRow(std::vector<double> x);
		std::vector<double> findColumn(std::vector<double> x);
		double FTestStatistic();
		double FrobeniusNorm();
		Matrix GaussianElimination();//exact calculation of row-echelon form
		double geometricMean();
		double get(int i, int j);
		int getPivot(int rw);
		int getReversePivot(int rw);
		Matrix GivensRotationMatrix(double a1, double a2, int r1, int r2);
		Matrix GramMatrix();
		Matrix GramMatrix(Matrix M);
		Matrix GramSchmidt();
		Matrix HadamardProduct(Matrix A, Matrix B);
		std::vector<Matrix> HouseholderQR();
		void identity();
		Matrix inverse();
		Matrix inverseExact();
		Matrix inverseByQR();
		bool isBoolean();
		bool isDiagonalized();
		bool isIntegerMatrix();
		bool isLinearlyIndependent();
		bool isOrderedSmallToLarge();
		bool isOrthonormal();
		bool isOverDetermined();
		bool isInconsistent(std::vector<double> b);
		bool isPositiveDefinite();
		bool isPositiveSemidefinite();
		bool isSingular();
		bool isSymmetric();
		bool isUnderDetermined();
		std::vector<int> JacobiIndexing();
		Matrix JacobiRotationMatrix(int p, int q, double c, double s);
		std::vector<Matrix> JacobiTransformation();
		Matrix L();
		std::vector<Matrix> LDL();
		Matrix leastSquares(Matrix X, Matrix Y);
		Function leastSquares();
		Matrix leastSquaresMatrix();
		Matrix lowerTriangularize();
		Matrix lowerHessenbergForm();
		std::vector<Matrix> LU();
		double mean();
		std::vector<double> meanVector();
		Matrix multiply(Matrix A, Matrix B);
		Matrix multiply(Matrix A, double B);
		void multiplyRow(int rw, double n);
		void multiplyRow(int rw, std::vector<double> n);
		double norm();
		void normalize();
		void normalizeColumn(int c);
		void normalizeRow(int r);
		std::vector<double> normalizedColumn(int c);
		std::vector<double> normalizedRow(int r);
		int nullity();
		Matrix nullSpace();
		Matrix operator*=(Matrix rhs);
		Matrix operator*=(double x);
		Matrix operator*(Matrix rhs);
		Matrix operator*(double x);
		Matrix operator+=(Matrix rhs);
		Matrix operator+=(double x);
		Matrix operator+(Matrix rhs);
		Matrix operator+(double x);
		Matrix operator-=(Matrix rhs);
		Matrix operator-=(double x);
		Matrix operator-(Matrix rhs);
		Matrix operator-(double x);
		Matrix operator^(double x);
		friend std::wostream& operator<<(std::wostream& os, Matrix rhs);
		bool operator==(Matrix B);
		Matrix outerProduct(Matrix A, Matrix B);
		double pNorm(double p);
		std::vector<int> pivotColumns();
		Matrix populationCovarianceMatrix();
		double populationStandardDeviation();
		void power(double n);
		void printToFile(std::wstring filename);
		Matrix pseudoinverse();
		Matrix Q();
		std::vector<Matrix> QR();
		Matrix R();
		void randomize();
		void randomizeInteger();
		void randomizeBoolean();
		void randomizeSymmetric();		
		Matrix reducedRowEchelonForm();//numerical method of calculating RRE form
		void removeColumn(int n);
		void removeRow(int n);
		void removeZeroRows();
		void removeZeroColumns();
		std::vector<double> residuals();
		void reverseColumn(int n);
		void reverseRow(int n);		
		std::vector<double> row(int r);
		double rowCovariance(int r1, int r2);
		double rowDeviation(int r);
		double rowNorm(int r);
		double rowAbsMax(int r);
		double rowMax(int r);
		double rowMean(int r);
		double rowAbsMin(int r);
		double rowMin(int r);
		int rowNonzeroValues(int rw);
		int rank();
		double rowSumSquares(int r);
		double rowVariance(int r);
		double Rsquared();
		Matrix sampleCovarianceMatrix();
		double sampleStandardDeviation();
		void set(int i, int j, double x);
		void setModulus(int n);
		void setColumnNonZeroValues(int col, double x);//subfunction for the solve() method
		void setRowNonZeroValues(int rw, double x);
		void setRow(int rw, std::vector<double> n);
		void setColumn(int col, std::vector<double> n);
		int size();
		bool solutionCheck(std::vector<double> x, std::vector<double> b);
		std::vector<double> solve(std::vector<double> b);//solve for Ax=b, where x will be the returned vector of variable values
		void sortRowsSmallToLarge();
		Matrix submatrix(int i, int j, int i2, int j2);
		Matrix subtract(Matrix A, Matrix B);
		Matrix subtract(Matrix A, double B);
		double sum();
		double sumAll();
		double sumColumn(int c);
		double sumRow(int r);
		double sumSquares();
		void swapRows(int r1, int r2);
		void swapColumns(int c1, int c2);
		Matrix swapOutZeroDiagonals();
		std::vector<Matrix> SVD();
		Matrix tensorProduct(Matrix A, Matrix B);
		std::vector<Matrix> thinQR();
		std::vector<Matrix> thinHouseholderQR();
		ComplexMatrix toComplexMatrix();
		std::vector<std::vector<double>> toVectorArray();
		Quaternion toQuaternion();
		std::wstring toString();
		Matrix transpose();
		double trace();
		void trim();
		Matrix U();
		Matrix upperTriangularize();
		Matrix upperHessenbergForm();
		Matrix Vandermonde();
		Matrix varianceMatrix();
		bool zeroInDiag();
};

class SparseMatrix {//sparse matrix with real, exact values.
public: std::vector<double> element;	//elements are stored as 3 items in Yale format:  (element, row, column)
		int rows;
		int columns;
		int size;
		int savedItems;
		int matrixPrecision;
		int largestElement;
		int modulus = 0;
SparseMatrix();
~SparseMatrix();
SparseMatrix(int row, int col);
 SparseMatrix(int row, int col, int items, double* element2);
 SparseMatrix(int row, int col, std::vector<double> element2);
  double get(int i, int j);
  void set(int i, int j, double x);
  void setModulus(int n);
  double sparsity();
  bool isIntegerMatrix();
  Matrix toMatrix();
  std::wstring toString();
  void display();
};//=================================

class ComplexMatrix {//matrix with real, exact values.  note: call row 1, column 1 with get(0,0)
	//note: matrix values are row-major indexed
public:
	std::vector<ComplexNumber> element;
	int rows;
	int columns;
	int size;
	int complexMatrixPrecision;
	int largestElementR;
	int largestElementC;
	ComplexMatrix();
	~ComplexMatrix();
	ComplexMatrix(int n);
	ComplexMatrix(int row, int col);
	ComplexMatrix(int row, int col, double* element2, double* celement2);
	ComplexMatrix(int row, int col, std::vector<double> element2, std::vector<double> celement2);
	ComplexMatrix(int row, int col, std::vector<ComplexNumber> elements);
	ComplexMatrix(int row, int col, std::vector<std::complex<double>> elements2);
		void randomize();
		void randomizeInteger();
		void randomizeBoolean();
		double getReal(int i, int j);
		void setReal(int i, int j, double x);
		double getImaginary(int i, int j);
		void setImaginary(int i, int j, double x);
		ComplexNumber get(int i, int j);
		void set(int i, int j, ComplexNumber x);
		void identity();
		ComplexMatrix submatrix(int i, int j, int i2, int j2);
		ComplexMatrix expandToUpperLeft(int r, int c);
		ComplexMatrix expandToLowerRight(int r, int c);
		ComplexMatrix extendRows(int r);
		ComplexMatrix extendColumns(int c);
		ComplexMatrix concatenate(ComplexMatrix A, ComplexMatrix B);
		ComplexMatrix multiply(ComplexMatrix A, ComplexMatrix B);
		ComplexMatrix multiply(ComplexMatrix A, double B);
		ComplexMatrix add(ComplexMatrix A, ComplexMatrix B);
		ComplexMatrix add(ComplexMatrix A, double B);
		ComplexMatrix subtract(ComplexMatrix A, ComplexMatrix B);
		ComplexMatrix subtract(ComplexMatrix A, double B);		
		ComplexMatrix exponent(ComplexMatrix A, int b);
		ComplexMatrix& operator*=(ComplexMatrix& rhs);
		ComplexMatrix& operator*=(double x);
		ComplexMatrix& operator*(ComplexMatrix& rhs);
		ComplexMatrix& operator*(double x);
		ComplexMatrix& operator+=(ComplexMatrix& rhs);
		ComplexMatrix& operator+=(double x);
		ComplexMatrix& operator+(ComplexMatrix& rhs);
		ComplexMatrix& operator+(double x);
		ComplexMatrix& operator-=(ComplexMatrix& rhs);
		ComplexMatrix& operator-=(double x);
		ComplexMatrix& operator-(ComplexMatrix& rhs);
		ComplexMatrix& operator-(double x);
		ComplexMatrix& operator^(double x);
		bool operator==(ComplexMatrix& B);
		friend std::wostream& operator<<(std::wostream& os, ComplexMatrix& rhs);
		bool isIntegerMatrix();
		bool isSymmetric();
		bool isBoolean();
		bool isDiagonalized();
		bool isHermitian();
		//bool isOrthoNormal();
		ComplexMatrix transpose();
		ComplexMatrix conjugateTranspose();
		ComplexMatrix outerProduct(ComplexMatrix A, ComplexMatrix B);
		std::wstring toString();
		void printToFile(std::wstring filename);
		void display();
};//================END ComplexMatrix CLASS
class DualNumberMatrix {
public:
	int rows;
	int columns;
	std::vector<DualNumber> element;
	int largestElement;
	int DualNumberMatrixPrecision;
	int largestElementR;
	int largestElementD;
	DualNumberMatrix();
	~DualNumberMatrix();
	DualNumberMatrix(int row, int col);
	DualNumberMatrix(int row, int col, std::vector<DualNumber> element2);
	DualNumber get(int n);
	DualNumber get(int i, int j);
	double getReal(int n);
	double getReal(int i, int j);
	double getDual(int n);
	double getDual(int i, int j);
	void set(int n, DualNumber d);
	void set(int i, int j, DualNumber d);
	int size();
	bool isDualNull();
	void identity();
	DualNumberMatrix submatrix(int i, int j, int i2, int j2);
	DualNumberMatrix transpose();
	DualNumberMatrix conjugateTranspose();
	DualNumberMatrix multiply(DualNumberMatrix A, DualNumberMatrix B);
	DualNumberMatrix multiply(DualNumberMatrix A, double B);
	DualNumberMatrix add(DualNumberMatrix A, DualNumberMatrix B);
	DualNumberMatrix add(DualNumberMatrix A, double B);
	DualNumberMatrix subtract(DualNumberMatrix A, DualNumberMatrix B);
	DualNumberMatrix subtract(DualNumberMatrix A, double B);
	DualNumberMatrix exponent(DualNumberMatrix A, int b);
	DualNumberMatrix operator*=(DualNumberMatrix rhs);
	DualNumberMatrix operator*=(double x);
	DualNumberMatrix operator*(DualNumberMatrix rhs);
	DualNumberMatrix operator*(double x);
	DualNumberMatrix operator+=(DualNumberMatrix rhs);
	DualNumberMatrix operator+=(double x);
	DualNumberMatrix operator+(DualNumberMatrix rhs);
	DualNumberMatrix operator+(double x);
	DualNumberMatrix operator-=(DualNumberMatrix rhs);
	DualNumberMatrix operator-=(double x);
	DualNumberMatrix operator-(DualNumberMatrix rhs);
	DualNumberMatrix operator-(double x);
	DualNumberMatrix operator^(double x);
	bool operator==(DualNumberMatrix& B);
	friend std::wostream& operator<<(std::wostream& os, DualNumberMatrix& rhs);
	std::wstring toString();
	void printToFile(std::wstring filename);
	void display();
	//====================================================
};
Matrix directionMatrix(Vector v);
Matrix identityMatrix(int n);
Matrix identityMatrix(int n, int m);
Matrix modelMatrix(Matrix T, Matrix R, Matrix S);
Matrix positionMatrix(Vector v);
Matrix rotationMatrix(std::vector<double> v);
Matrix rotationMatrix(Quaternion v);
Matrix scalingMatrix(std::vector<double> v);
Matrix translationMatrix(std::vector<double> v);
Matrix Vandermonde(Polynomial p);
#endif